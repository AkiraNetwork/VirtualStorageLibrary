<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="NodeNotFound" xml:space="preserve">
    <value>Node not found. [{0}]</value>
    <comment>Notifies if a node is not found while processing nodes included in the path.</comment>
  </data>
  <data name="RootAlreadyExists" xml:space="preserve">
    <value>The root directory already exists.</value>
    <comment>Notifies if a root directory is specified when creating a directory.</comment>
  </data>
  <data name="InvalidNodeName" xml:space="preserve">
    <value>Node name [{0}] is invalid. Forbidden characters are used.</value>
    <comment>Notifies if forbidden characters are included in the node name.</comment>
  </data>
  <data name="NodeAlreadyExists" xml:space="preserve">
    <value>Node [{0}] already exists. Overwriting is not allowed.</value>
    <comment>Notifies when adding a node if a node already exists and overwriting is not allowed.</comment>
  </data>
  <data name="NodeIsNotVirtualItem" xml:space="preserve">
    <value>The specified node [{0}] is not of type VirtualItem&lt;{1}&gt;.</value>
    <comment>Notifies if the specified node type is not VirtualItem&lt;T&gt;.</comment>
  </data>
  <data name="NodeIsNotVirtualDirectory" xml:space="preserve">
    <value>The specified node [{0}] is not of type VirtualDirectory.</value>
    <comment>Notifies if the specified node type is not VirtualDirectory.</comment>
  </data>
  <data name="NodeIsNotVirtualSymbolicLink" xml:space="preserve">
    <value>The specified node [{0}] is not of type VirtualSymbolicLink.</value>
    <comment>Notifies if the specified node type is not VirtualSymbolicLink.</comment>
  </data>
  <data name="PrefixIsEmpty" xml:space="preserve">
    <value>Prefix cannot be empty.</value>
    <comment>Notifies if the specified prefix is empty.</comment>
  </data>
  <data name="PathNormalizationAboveRoot" xml:space="preserve">
    <value>Due to path normalization, it is above the root directory. [{0}]</value>
    <comment>Notifies when path normalization results in the path being above the root directory.</comment>
  </data>
  <data name="ParameterIsNotVirtualPath" xml:space="preserve">
    <value>The object specified by the parameter is not of type VirtualPath.</value>
    <comment>Notifies when comparing paths if the type of the object specified by the parameter is not VirtualPath.</comment>
  </data>
  <data name="PathIsNotAbsolutePath" xml:space="preserve">
    <value>This path is not an absolute path. [{0}]</value>
    <comment>Notifies when obtaining a relative path if the path within VirtualPath is not an absolute path.</comment>
  </data>
  <data name="BasePathIsNotAbsolute" xml:space="preserve">
    <value>The specified base path is not an absolute path. [{0}]</value>
    <comment>Notifies when obtaining a relative path if the specified base path is not an absolute path.</comment>
  </data>
  <data name="ParameterIsNotVirtualNodeName" xml:space="preserve">
    <value>The object specified by the parameter is not of type VirtualNodeName.</value>
    <comment>Notifies if the type of the object specified by the parameter is not VirtualNodeName.</comment>
  </data>
  <data name="TargetPathIsNotAbsolutePath" xml:space="preserve">
    <value>The target path specified in the parameter must be an absolute path. [{0}]</value>
    <comment>Notifies if the target path specified by the parameter is not an absolute path.</comment>
  </data>
  <data name="LinkPathIsNotAbsolutePath" xml:space="preserve">
    <value>The symbolic link path specified in the parameter must be an absolute path. [{0}]</value>
    <comment>Notifies if the symbolic link path specified by the parameter is not an absolute path.</comment>
  </data>
  <data name="ParameterIsNullOrEmpty" xml:space="preserve">
    <value>The values ​​specified in the parameters are null or empty. [{0}]</value>
    <comment>Notifies if the value specified by the parameter is NULL or empty.</comment>
  </data>
  <data name="ParameterIsEmpty" xml:space="preserve">
    <value>The values ​​specified in the parameters are empty. [{0}]</value>
    <comment>Notifies if the value specified by the parameter is empty.</comment>
  </data>
  <data name="CannotReachBecauseNodeItem" xml:space="preserve">
    <value>Cannot reach node [{0}]. Node [{1}] is an item.</value>
    <comment>Notifies when path traversal cannot continue because an intermediate node is an item.</comment>
  </data>
  <data name="CannotReachBecauseNodeSymbolicLink" xml:space="preserve">
    <value>Cannot reach node [{0}]. Node [{1}] is a symbolic link, and the followLinks parameter is set to false.</value>
    <comment>Notifies when path traversal cannot continue because an intermediate node is a symbolic link and the followLinks parameter is false.</comment>
  </data>
  <data name="CircularReferenceDetected" xml:space="preserve">
    <value>Circular reference detected. [{0}] [{1}]</value>
    <comment>Notifies when a circular reference in the path is detected during path traversal.</comment>
  </data>
  <data name="PathCannotBeEmpty" xml:space="preserve">
    <value>An empty string cannot be specified as a path.</value>
    <comment>Notifies if the specified path is an empty string.</comment>
  </data>
  <data name="RecursiveSubdirectoryConflict" xml:space="preserve">
    <value>If the recursive parameter is set to true, the source or destination cannot be a subdirectory of each other. [{0}] [{1}]</value>
    <comment>Notifies when copying nodes if the recursive parameter is set to true and the source or destination is a subdirectory of each other.</comment>
  </data>
  <data name="PathNotFound" xml:space="preserve">
    <value>Path not found. [{0}]</value>
    <comment>Notifies if a path is not found while processing nodes included in the path.</comment>
  </data>
  <data name="SourceAndDestinationPathSame" xml:space="preserve">
    <value>The source path and the destination path are the same.</value>
    <comment>Notifies when copying nodes if the source path and the destination path are the same.</comment>
  </data>
  <data name="CannotAddRoot" xml:space="preserve">
    <value>Cannot add the root to a directory.</value>
    <comment>Notifies when attempting to add the root to a directory.</comment>
  </data>
  <data name="NegativeDepthValue" xml:space="preserve">
    <value>Depth has become a negative value. [{0}]</value>
    <comment>Notifies when an internal inconsistency occurs in the depth calculation set in the context during the node copy process.</comment>
  </data>
</root>